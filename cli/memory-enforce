#!/usr/bin/env node

/**
 * Institutional Memory Enforcement CLI
 * 
 * Command-line tool for validating and maintaining institutional memory integrity.
 * Usage: ./cli/memory-enforce [command] [options]
 */

const { program } = require('commander');
const InstitutionalMemoryEnforcer = require('../institutional-memory-enforcer.js');
const chalk = require('chalk');
const path = require('path');

// Initialize enforcer
const enforcer = new InstitutionalMemoryEnforcer(process.cwd());

program
  .name('memory-enforce')
  .description('Institutional Memory Enforcement CLI')
  .version('1.0.0');

// Validate command - run all checks
program
  .command('validate')
  .description('Run complete institutional memory validation')
  .option('-v, --verbose', 'show detailed output')
  .action(async (options) => {
    console.log(chalk.blue('üîç Running institutional memory validation...\n'));
    
    try {
      const results = await enforcer.runMandatoryPreChecks();
      
      console.log(chalk.green('‚úÖ ALL CHECKS PASSED'));
      
      if (options.verbose) {
        console.log('\nDetailed Results:');
        console.log(JSON.stringify(results, null, 2));
      }
      
      // Also run drift detection
      console.log(chalk.blue('\nüîç Checking for institutional memory drift...'));
      const driftResults = await enforcer.detectDrift();
      
      if (driftResults.driftDetected) {
        console.log(chalk.yellow('‚ö†Ô∏è  DRIFT DETECTED:'));
        driftResults.issues.forEach(issue => {
          console.log(chalk.yellow(`  - ${issue.type}: ${issue.count || 'detected'}`));
        });
        console.log('\nRecommended actions:');
        driftResults.recommendedActions.forEach(action => {
          console.log(chalk.cyan(`  ‚Ä¢ ${action}`));
        });
        process.exit(1);
      } else {
        console.log(chalk.green('‚úÖ No drift detected - institutional memory is current'));
      }
      
    } catch (error) {
      console.error(chalk.red('‚ùå VALIDATION FAILED:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Check command - quick health check
program
  .command('check')
  .description('Quick health check of institutional memory files')
  .action(async () => {
    console.log(chalk.blue('üîç Quick institutional memory health check...\n'));
    
    try {
      const filesExist = await enforcer.validateFilesExist();
      const structure = await enforcer.validateFileStructure();
      
      if (filesExist.passed) {
        console.log(chalk.green('‚úÖ Required files exist'));
      } else {
        console.log(chalk.red('‚ùå Missing required files'));
        console.log(chalk.red(JSON.stringify(filesExist.details, null, 2)));
      }
      
      if (structure.passed) {
        console.log(chalk.green('‚úÖ File structure valid'));
      } else {
        console.log(chalk.red('‚ùå Invalid file structure'));
        console.log(chalk.red(JSON.stringify(structure.details, null, 2)));
      }
      
      if (!filesExist.passed || !structure.passed) {
        process.exit(1);
      }
      
    } catch (error) {
      console.error(chalk.red('‚ùå CHECK FAILED:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Decision command - capture new architectural decision
program
  .command('decision')
  .description('Capture a new architectural decision')
  .option('-t, --title <title>', 'decision title')
  .option('-c, --context <context>', 'project context')
  .option('-s, --standard <standard>', 'technical standard')
  .option('-r, --rationale <rationale>', 'decision rationale')
  .option('--scope <scope>', 'application scope')
  .action(async (options) => {
    if (!options.title || !options.context || !options.standard || !options.rationale) {
      console.error(chalk.red('‚ùå Missing required options. All of --title, --context, --standard, --rationale are required.'));
      process.exit(1);
    }
    
    const decision = {
      title: options.title,
      context: options.context,
      standard: options.standard,
      rationale: options.rationale,
      scope: options.scope || 'This project'
    };
    
    try {
      const result = await enforcer.captureNewDecision(decision);
      console.log(chalk.green('‚úÖ Decision captured successfully'));
      console.log(chalk.blue('Decision entry:'));
      console.log(result.entry);
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to capture decision:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Pattern command - capture new coordination pattern
program
  .command('pattern')
  .description('Capture a new coordination pattern')
  .option('-n, --name <name>', 'pattern name')
  .option('-c, --context <context>', 'discovery context')
  .option('-d, --description <description>', 'pattern description')
  .option('-u, --usage <usage>', 'how to use pattern')
  .option('-i, --integrations <integrations>', 'integration points (comma-separated)')
  .action(async (options) => {
    if (!options.name || !options.context || !options.description || !options.usage) {
      console.error(chalk.red('‚ùå Missing required options. All of --name, --context, --description, --usage are required.'));
      process.exit(1);
    }
    
    const pattern = {
      name: options.name,
      context: options.context,
      description: options.description,
      usage: options.usage,
      integrations: options.integrations ? options.integrations.split(',').map(s => s.trim()) : []
    };
    
    try {
      const result = await enforcer.captureNewPattern(pattern);
      console.log(chalk.green('‚úÖ Pattern captured successfully'));
      console.log(chalk.blue('Pattern entry:'));
      console.log(result.entry);
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to capture pattern:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Drift command - detect institutional memory drift
program
  .command('drift')
  .description('Detect institutional memory drift and inconsistencies')
  .action(async () => {
    console.log(chalk.blue('üîç Scanning for institutional memory drift...\n'));
    
    try {
      const results = await enforcer.detectDrift();
      
      if (!results.driftDetected) {
        console.log(chalk.green('‚úÖ No drift detected - institutional memory is current and consistent'));
        return;
      }
      
      console.log(chalk.yellow('‚ö†Ô∏è  INSTITUTIONAL MEMORY DRIFT DETECTED\n'));
      
      results.issues.forEach((issue, index) => {
        console.log(chalk.yellow(`${index + 1}. ${issue.type}`));
        if (issue.count) {
          console.log(chalk.gray(`   Count: ${issue.count}`));
        }
        if (issue.details && Array.isArray(issue.details)) {
          issue.details.forEach(detail => {
            console.log(chalk.gray(`   - ${detail}`));
          });
        }
        console.log('');
      });
      
      console.log(chalk.cyan('RECOMMENDED ACTIONS:'));
      results.recommendedActions.forEach(action => {
        console.log(chalk.cyan(`‚Ä¢ ${action}`));
      });
      
      process.exit(1);
      
    } catch (error) {
      console.error(chalk.red('‚ùå DRIFT DETECTION FAILED:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Init command - initialize institutional memory files
program
  .command('init')
  .description('Initialize institutional memory files for new project')
  .option('--force', 'overwrite existing files')
  .action(async (options) => {
    console.log(chalk.blue('üöÄ Initializing institutional memory system...\n'));
    
    const fs = require('fs');
    const projectMemoryDir = path.join(process.cwd(), 'project-memory');
    const conventionsPath = path.join(projectMemoryDir, 'conventions.md');
    const symbolIndexPath = path.join(projectMemoryDir, 'symbol-index.md');
    
    // Create project-memory directory if it doesn't exist
    if (!fs.existsSync(projectMemoryDir)) {
      fs.mkdirSync(projectMemoryDir, { recursive: true });
      console.log(chalk.green('‚úÖ Created project-memory directory'));
    }
    
    // Check if files already exist
    if (fs.existsSync(conventionsPath) && !options.force) {
      console.error(chalk.yellow('‚ö†Ô∏è  conventions.md already exists. Use --force to overwrite.'));
      process.exit(1);
    }
    
    if (fs.existsSync(symbolIndexPath) && !options.force) {
      console.error(chalk.yellow('‚ö†Ô∏è  symbol-index.md already exists. Use --force to overwrite.'));
      process.exit(1);
    }
    
    // Create template conventions.md
    const conventionsTemplate = `# Team Conventions & Architectural Decisions

*Team-wide architectural decisions and coding standards that guide all development work. These conventions are the single source of truth for all development decisions.*

**Priority**: HIGHEST - Team conventions are the only decision source (no individual preferences)  
**Scope**: All team members must follow these decisions  
**Updates**: Requires team consensus or technical lead approval  
**Updated**: ${new Date().toISOString().split('T')[0]} (initialized by institutional memory enforcer)

## Technology Stack Preferences

### Development Standards
**Decision Made**: ${new Date().toISOString().split('T')[0]} (Project initialization)  
**Technology**: [To be determined based on project requirements]  
**Rationale**: [To be documented when technology decisions are made]  
**Apply To**: [Scope to be defined]  

## Security Standards

### Security Requirements  
**Decision Made**: ${new Date().toISOString().split('T')[0]} (Project initialization)  
**Standard**: [Security standards to be determined]  
**Implementation**: [Implementation details to be documented]  
**Apply To**: All systems and components  

## Code Quality Standards

### Quality Requirements
**Decision Made**: ${new Date().toISOString().split('T')[0]} (Project initialization)  
**Standards**: [Quality standards to be determined]  
**Apply To**: All production code  

---

*This conventions file is automatically maintained by the institutional memory enforcement system. It ensures consistent application of team preferences across all projects, preventing architectural drift and maintaining enterprise-grade consistency.*
`;

    // Create template symbol-index.md
    const symbolIndexTemplate = `# Codebase Symbol Index & Dependencies

*Maintains an index of codebase structure, function dependencies, and interconnections. This context enables development work to understand existing code and make changes without breaking integrations.*

**Key Function**: This maintains an index of your codebase structure, function dependencies, and interconnections - providing context needed to understand and modify existing code without breaking integrations.

**Updated**: ${new Date().toISOString().split('T')[0]} (initialized by institutional memory enforcer)

## Core Service Architecture

### Core Services
*[To be populated as services are identified and documented]*

**Dependencies**:
- [Service dependencies to be documented]

**Exports**:
- [Service exports to be documented]

**Integration Points**:
- [Integration points to be documented]

## Agent Coordination Discoveries

### Successful Coordination Patterns
*[Discovered during actual project work - populated automatically]*

**Pattern**: [Name of coordination approach]
- **Context**: [Project/feature context]
- **Approach**: [How coordination was achieved]  
- **Success indicators**: [Why this approach was effective]
- **Reusability**: [When this pattern applies to future projects]

## Connection Network Evolution

### Relationship Discoveries
*[Mapped as relationships prove effective or problematic]*

**Effective Patterns**:
- [Effective coordination patterns to be discovered]

**Integration Points**:  
- [Integration challenges and solutions to be documented]

---

*This document grows through actual project experience. Each development session adds discovered patterns, successful relationships, and integration solutions that improve future development work.*
`;

    try {
      fs.writeFileSync(conventionsPath, conventionsTemplate);
      console.log(chalk.green('‚úÖ Created conventions.md template'));
      
      fs.writeFileSync(symbolIndexPath, symbolIndexTemplate);
      console.log(chalk.green('‚úÖ Created symbol-index.md template'));
      
      console.log(chalk.blue('\nüéâ Institutional memory system initialized successfully!'));
      console.log(chalk.gray('\nNext steps:'));
      console.log(chalk.gray('1. Populate conventions.md with your team\'s architectural decisions'));
      console.log(chalk.gray('2. Document your codebase structure in symbol-index.md'));
      console.log(chalk.gray('3. Run "memory-enforce validate" to verify setup'));
      
    } catch (error) {
      console.error(chalk.red('‚ùå Initialization failed:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Search command - find existing decisions in conventions.md
program
  .command('search')
  .description('Search for existing decisions in conventions.md')
  .argument('<query>', 'search term or pattern')
  .option('-e, --exact', 'exact match instead of pattern matching')
  .option('-s, --section <section>', 'search within specific section')
  .action(async (query, options) => {
    console.log(chalk.blue(`üîç Searching conventions.md for: "${query}"\n`));

    try {
      const searchResults = await enforcer.searchConventions(query, {
        exact: options.exact,
        section: options.section
      });

      if (searchResults.length === 0) {
        console.log(chalk.yellow('‚ùì No existing decisions found for this query'));
        console.log(chalk.gray('\nSuggested search alternatives:'));
        const suggestions = await enforcer.generateSearchSuggestions(query);
        suggestions.forEach(suggestion => {
          console.log(chalk.gray(`  ‚Ä¢ ${suggestion}`));
        });
      } else {
        console.log(chalk.green(`‚úÖ Found ${searchResults.length} related decision(s):\n`));
        searchResults.forEach((result, index) => {
          console.log(chalk.cyan(`${index + 1}. ${result.title}`));
          console.log(chalk.gray(`   Standard: ${result.standard}`));
          console.log(chalk.gray(`   Scope: ${result.scope}`));
          console.log('');
        });
      }

    } catch (error) {
      console.error(chalk.red('‚ùå Search failed:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Index command - navigate and query symbol-index.md
program
  .command('index')
  .description('Query and navigate symbol-index.md')
  .option('-f, --functions [pattern]', 'list functions matching pattern')
  .option('-c, --connections [component]', 'show connections for component')
  .option('-p, --patterns', 'list discovered patterns')
  .option('--stats', 'show symbol index statistics')
  .action(async (options) => {
    console.log(chalk.blue('üîç Querying symbol index...\n'));

    try {
      if (options.stats) {
        const stats = await enforcer.getSymbolIndexStats();
        console.log(chalk.cyan('üìä Symbol Index Statistics:'));
        console.log(chalk.gray(`  Functions: ${stats.functions}`));
        console.log(chalk.gray(`  Connections: ${stats.connections}`));
        console.log(chalk.gray(`  Patterns: ${stats.patterns}`));
        console.log(chalk.gray(`  Last Updated: ${stats.lastUpdated}`));
        return;
      }

      if (options.functions !== undefined) {
        const functions = await enforcer.queryFunctions(options.functions || '');
        console.log(chalk.green(`üìã Functions${options.functions ? ` matching "${options.functions}"` : ''}:`));
        functions.forEach(func => {
          console.log(chalk.cyan(`  ‚Ä¢ ${func.name} (${func.file})`));
          console.log(chalk.gray(`    ${func.purpose}`));
        });
      }

      if (options.connections !== undefined) {
        const connections = await enforcer.queryConnections(options.connections || '');
        console.log(chalk.green(`üîó Connections${options.connections ? ` for "${options.connections}"` : ''}:`));
        connections.forEach(conn => {
          console.log(chalk.cyan(`  ‚Ä¢ ${conn.from} ‚Üí ${conn.to}`));
          console.log(chalk.gray(`    ${conn.purpose} (${conn.type})`));
        });
      }

      if (options.patterns) {
        const patterns = await enforcer.queryPatterns();
        console.log(chalk.green('üéØ Discovered Patterns:'));
        patterns.forEach(pattern => {
          console.log(chalk.cyan(`  ‚Ä¢ ${pattern.name}`));
          console.log(chalk.gray(`    ${pattern.description}`));
          console.log(chalk.gray(`    Usage: ${pattern.usage}`));
        });
      }

      if (!options.functions && !options.connections && !options.patterns && !options.stats) {
        console.log(chalk.yellow('‚ùì Please specify what to query:'));
        console.log(chalk.gray('  --functions [pattern]  - List functions'));
        console.log(chalk.gray('  --connections [comp]   - Show connections'));
        console.log(chalk.gray('  --patterns            - List patterns'));
        console.log(chalk.gray('  --stats               - Show statistics'));
      }

    } catch (error) {
      console.error(chalk.red('‚ùå Index query failed:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  });

// Core command - focus on core file health and utilities
program
  .command('core')
  .description('Core file utilities for conventions.md and symbol-index.md')
  .option('--health', 'check core file health')
  .option('--template <type>', 'show template for decision type')
  .option('--conflicts', 'detect decision conflicts')
  .option('--orphans', 'find orphaned symbol references')
  .action(async (options) => {
    if (options.health) {
      console.log(chalk.blue('üè• Core File Health Check...\n'));

      const conventionsHealth = await enforcer.checkConventionsHealth();
      const symbolIndexHealth = await enforcer.checkSymbolIndexHealth();

      console.log(chalk.cyan('üìã conventions.md:'));
      console.log(chalk.gray(`  Decisions: ${conventionsHealth.decisions}`));
      console.log(chalk.gray(`  Sections: ${conventionsHealth.sections}`));
      console.log(chalk.gray(`  Recent Activity: ${conventionsHealth.recentActivity}`));

      console.log(chalk.cyan('\nüîó symbol-index.md:'));
      console.log(chalk.gray(`  Functions: ${symbolIndexHealth.functions}`));
      console.log(chalk.gray(`  Connections: ${symbolIndexHealth.connections}`));
      console.log(chalk.gray(`  Patterns: ${symbolIndexHealth.patterns}`));
      console.log(chalk.gray(`  Stale References: ${symbolIndexHealth.staleReferences}`));
    }

    if (options.template) {
      const template = await enforcer.getDecisionTemplate(options.template);
      console.log(chalk.blue(`üìù Template for ${options.template}:\n`));
      console.log(template);
    }

    if (options.conflicts) {
      console.log(chalk.blue('‚öîÔ∏è  Checking for decision conflicts...\n'));
      const conflicts = await enforcer.detectDecisionConflicts();

      if (conflicts.length === 0) {
        console.log(chalk.green('‚úÖ No conflicts detected'));
      } else {
        console.log(chalk.yellow(`‚ö†Ô∏è  Found ${conflicts.length} potential conflict(s):`));
        conflicts.forEach(conflict => {
          console.log(chalk.red(`  ‚Ä¢ ${conflict.decision1.title} vs ${conflict.decision2.title}`));
          console.log(chalk.gray(`    Overlap: ${conflict.reason}`));
        });
      }
    }

    if (options.orphans) {
      console.log(chalk.blue('üîç Finding orphaned symbol references...\n'));
      const orphans = await enforcer.findOrphanedReferences();

      if (orphans.length === 0) {
        console.log(chalk.green('‚úÖ No orphaned references found'));
      } else {
        console.log(chalk.yellow(`‚ö†Ô∏è  Found ${orphans.length} orphaned reference(s):`));
        orphans.forEach(orphan => {
          console.log(chalk.red(`  ‚Ä¢ ${orphan.reference} (${orphan.type})`));
          console.log(chalk.gray(`    Found in: ${orphan.location}`));
        });
      }
    }

    if (!options.health && !options.template && !options.conflicts && !options.orphans) {
      console.log(chalk.yellow('‚ùì Please specify a core file utility:'));
      console.log(chalk.gray('  --health              - Check core file health'));
      console.log(chalk.gray('  --template <type>     - Show decision template'));
      console.log(chalk.gray('  --conflicts          - Detect conflicts'));
      console.log(chalk.gray('  --orphans            - Find orphaned references'));
    }
  });

program.parse();